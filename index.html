<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echoes of Terra Map Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }

        #map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
            background: #000;
        }

        #map-container:active {
            cursor: grabbing;
        }

        #map-canvas {
            position: absolute;
            transition: transform 0.1s ease-out;
            touch-action: none; /* 禁用默认触控行为 */
        }

        .tile {
            position: absolute;
            width: 256px;
            height: 256px;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            /* border: 1px solid rgba(255, 255, 255, 0.1); */
        }

        .tile.loaded {
            opacity: 1;
        }

        .tile.preloaded {
            opacity: 0.8;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #333;
            z-index: 1000;
        }

        #zoom-level {
            margin-bottom: 10px;
            font-size: 14px;
        }

        #zoom-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .zoom-btn {
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .zoom-btn:hover {
            background: #555;
        }

        .zoom-btn.active {
            background: #0066cc;
        }

        #coordinates {
            font-size: 12px;
            color: #ccc;
        }

        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            font-size: 12px;
            color: #ccc;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        a {
            color: #0066cc;
            text-decoration: none;
        }
    </style>
</head>
<body>
    <div id="map-container">
        <div id="map-canvas"></div>
    </div>

    <div id="controls">
        <div id="zoom-level">缩放级别: <span id="current-zoom">0</span></div>
        <div id="zoom-buttons">
            <button class="zoom-btn active" data-zoom="0">0</button>
            <button class="zoom-btn" data-zoom="1">1</button>
            <button class="zoom-btn" data-zoom="2">2</button>
            <button class="zoom-btn" data-zoom="3">3</button>
            <button class="zoom-btn" data-zoom="4">4</button>
        </div>
        <div id="coordinates">
            X: <span id="coord-x">500</span>, Y: <span id="coord-y">500</span>
        </div>
    </div>

    <div id="info">
        <p>地图数据来自 Echoes of Terra</p>
        <p>资源版权归 <a href="https://ak.hypergryph.com/">鹰角网络</a> 所有</p>
        <p>本项目(<a href="https://github.com/RavelloH/EchoesOfTerraMap">RavelloH/EchoesOfTerraMap</a>)只是一个开源地图查看器。</p>
    </div>

    <div id="loading" class="loading" style="display: none;">
        加载地图数据中...
    </div>

    <script>
        class MapViewer {
            constructor() {
                this.mapData = null;
                this.currentZoom = 0;
                this.centerX = 500;
                this.centerY = 500;
                this.tileSize = 256;
                this.viewportWidth = window.innerWidth;
                this.viewportHeight = window.innerHeight;
                this.offsetX = 0;
                this.offsetY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;

                // 触控相关变量
                this.touches = [];
                this.lastTouchDistance = 0;
                this.isZooming = false;

                // 预载相关
                this.preloadBuffer = 2; // 预载缓冲区大小（瓦片数量）
                this.loadedTiles = new Set(); // 已加载的瓦片集合
                this.preloadQueue = []; // 预载队列

                this.mapContainer = document.getElementById('map-container');
                this.mapCanvas = document.getElementById('map-canvas');
                this.currentZoomSpan = document.getElementById('current-zoom');
                this.coordXSpan = document.getElementById('coord-x');
                this.coordYSpan = document.getElementById('coord-y');

                this.init();
            }

            async init() {
                await this.loadMapData();
                this.setupEventListeners();
                this.render();
            }

            async loadMapData() {
                try {
                    document.getElementById('loading').style.display = 'block';
                    const response = await fetch('./index.json');
                    this.mapData = await response.json();
                    document.getElementById('loading').style.display = 'none';
                } catch (error) {
                    console.error('Failed to load map data:', error);
                    document.getElementById('loading').innerHTML = '加载地图数据失败';
                }
            }

            setupEventListeners() {
                // 缩放控制
                document.querySelectorAll('.zoom-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const zoom = parseInt(e.target.dataset.zoom);
                        this.setZoom(zoom);
                        
                        // 更新按钮状态
                        document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });

                // 鼠标拖拽
                this.mapContainer.addEventListener('mousedown', (e) => {
                    if (e.touches) return; // 如果是触控事件，忽略鼠标事件
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!this.isDragging || e.touches) return;

                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;

                    this.offsetX += deltaX;
                    this.offsetY += deltaY;

                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;

                    this.updateTransform();
                    this.updateCoordinates();
                });

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.render(); // 重新渲染可见区域
                    }
                });

                // 触控事件处理
                this.mapContainer.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.touches = Array.from(e.touches);
                    
                    if (this.touches.length === 1) {
                        // 单指拖拽
                        this.isDragging = true;
                        this.lastMouseX = this.touches[0].clientX;
                        this.lastMouseY = this.touches[0].clientY;
                    } else if (this.touches.length === 2) {
                        // 双指缩放
                        this.isDragging = false;
                        this.isZooming = true;
                        this.lastTouchDistance = this.getTouchDistance(this.touches);
                    }
                });

                this.mapContainer.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.touches = Array.from(e.touches);
                    
                    if (this.touches.length === 1 && this.isDragging && !this.isZooming) {
                        // 单指拖拽
                        const deltaX = this.touches[0].clientX - this.lastMouseX;
                        const deltaY = this.touches[0].clientY - this.lastMouseY;

                        this.offsetX += deltaX;
                        this.offsetY += deltaY;

                        this.lastMouseX = this.touches[0].clientX;
                        this.lastMouseY = this.touches[0].clientY;

                        this.updateTransform();
                        this.updateCoordinates();
                    } else if (this.touches.length === 2 && this.isZooming) {
                        // 双指缩放
                        const currentDistance = this.getTouchDistance(this.touches);
                        const distanceChange = currentDistance - this.lastTouchDistance;
                        
                        // 根据距离变化调整缩放
                        if (Math.abs(distanceChange) > 10) { // 防止过于敏感
                            const zoomDirection = distanceChange > 0 ? -1 : 1; // 注意方向
                            const newZoom = Math.max(0, Math.min(4, this.currentZoom + zoomDirection));
                            
                            if (newZoom !== this.currentZoom) {
                                // 计算双指中心点进行缩放
                                const centerX = (this.touches[0].clientX + this.touches[1].clientX) / 2;
                                const centerY = (this.touches[0].clientY + this.touches[1].clientY) / 2;
                                this.setZoomAtPoint(newZoom, centerX, centerY);
                                
                                // 更新按钮状态
                                document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
                                document.querySelector(`[data-zoom="${newZoom}"]`).classList.add('active');
                            }
                            
                            this.lastTouchDistance = currentDistance;
                        }
                    }
                });

                this.mapContainer.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.touches = Array.from(e.touches);
                    
                    if (this.touches.length === 0) {
                        // 所有手指离开
                        if (this.isDragging) {
                            this.isDragging = false;
                            this.render(); // 重新渲染可见区域
                        }
                        this.isZooming = false;
                    } else if (this.touches.length === 1) {
                        // 从双指变为单指
                        this.isZooming = false;
                        this.isDragging = true;
                        this.lastMouseX = this.touches[0].clientX;
                        this.lastMouseY = this.touches[0].clientY;
                    }
                });

                // 窗口大小变化
                window.addEventListener('resize', () => {
                    this.viewportWidth = window.innerWidth;
                    this.viewportHeight = window.innerHeight;
                    this.render();
                });

                // 鼠标滚轮缩放
                this.mapContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 1 : -1;
                    const newZoom = Math.max(0, Math.min(4, this.currentZoom + delta));
                    if (newZoom !== this.currentZoom) {
                        this.setZoom(newZoom);
                        document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
                        document.querySelector(`[data-zoom="${newZoom}"]`).classList.add('active');
                    }
                });
            }

            // 计算两个触点之间的距离
            getTouchDistance(touches) {
                if (touches.length < 2) return 0;
                
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // 在指定点进行缩放（用于双指缩放）
            setZoomAtPoint(zoom, pointX, pointY) {
                // 计算相对于视口的点坐标
                const rect = this.mapContainer.getBoundingClientRect();
                const relativeX = pointX - rect.left;
                const relativeY = pointY - rect.top;
                
                // 计算该点对应的世界坐标
                const worldX = (relativeX - this.offsetX) / this.tileSize + this.centerX;
                const worldY = this.centerY - (relativeY - this.offsetY) / this.tileSize;
                
                // 更新缩放级别
                this.currentZoom = zoom;
                this.currentZoomSpan.textContent = zoom;
                
                // 重新计算偏移量，保持指定点的世界坐标不变
                this.offsetX = relativeX - (worldX - this.centerX) * this.tileSize;
                this.offsetY = relativeY - (this.centerY - worldY) * this.tileSize;
                
                this.loadedTiles.clear(); // 清空已加载瓦片记录
                this.render();
            }

            setZoom(zoom) {
                // 记录当前视口中心点的屏幕坐标
                const viewportCenterX = this.viewportWidth / 2;
                const viewportCenterY = this.viewportHeight / 2;
                
                // 计算当前视口中心对应的世界坐标
                const worldCenterX = (viewportCenterX - this.offsetX) / this.tileSize + this.centerX;
                const worldCenterY = this.centerY - (viewportCenterY - this.offsetY) / this.tileSize;
                
                // 更新缩放级别
                this.currentZoom = zoom;
                this.currentZoomSpan.textContent = zoom;
                
                // 重新计算偏移量，保持世界坐标中心点在视口中心
                this.offsetX = viewportCenterX - (worldCenterX - this.centerX) * this.tileSize;
                this.offsetY = viewportCenterY - (this.centerY - worldCenterY) * this.tileSize;
                
                this.loadedTiles.clear(); // 清空已加载瓦片记录
                this.render();
            }

            updateTransform() {
                this.mapCanvas.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px)`;
            }

            updateCoordinates() {
                // 计算当前视图中心对应的地图坐标
                const viewportCenterX = this.viewportWidth / 2;
                const viewportCenterY = this.viewportHeight / 2;
                
                const centerMapX = (viewportCenterX - this.offsetX) / this.tileSize + this.centerX;
                const centerMapY = this.centerY - (viewportCenterY - this.offsetY) / this.tileSize;
                
                this.coordXSpan.textContent = Math.round(centerMapX);
                this.coordYSpan.textContent = Math.round(centerMapY);
            }

            render() {
                if (!this.mapData || !this.mapData[this.currentZoom]) return;

                // 清空当前地图
                this.mapCanvas.innerHTML = '';
                
                const zoomData = this.mapData[this.currentZoom];
                
                // 收集可视区域的瓦片
                const visibleTiles = [];
                const preloadTiles = [];
                
                for (const [chunkKey, tiles] of Object.entries(zoomData)) {
                    tiles.forEach(tileFile => {
                        const match = tileFile.match(/r_(\d+)_([^_]+)_(\d+)_(\d+)\.png/);
                        if (match) {
                            const [, zoomLevel, chunk, x, y] = match;
                            const tileX = parseInt(x);
                            const tileY = parseInt(y);
                            
                            // 计算瓦片在屏幕上的位置
                            const screenX = (tileX - this.centerX) * this.tileSize;
                            const screenY = (tileY - this.centerY) * this.tileSize;
                            
                            const tileInfo = {
                                file: tileFile,
                                chunk: chunk,
                                x: tileX,
                                y: tileY,
                                screenX: screenX,
                                screenY: screenY,
                                zIndex: this.calculateZIndex(chunk)
                            };
                            
                            // 检查是否在可视范围内
                            const visibleBuffer = this.tileSize;
                            if (screenX >= -this.offsetX - visibleBuffer && 
                                screenX <= -this.offsetX + this.viewportWidth + visibleBuffer &&
                                screenY >= -this.offsetY - visibleBuffer && 
                                screenY <= -this.offsetY + this.viewportHeight + visibleBuffer) {
                                visibleTiles.push(tileInfo);
                            } else {
                                // 检查是否在预载范围内
                                const preloadBuffer = this.tileSize * (this.preloadBuffer + 1);
                                if (screenX >= -this.offsetX - preloadBuffer && 
                                    screenX <= -this.offsetX + this.viewportWidth + preloadBuffer &&
                                    screenY >= -this.offsetY - preloadBuffer && 
                                    screenY <= -this.offsetY + this.viewportHeight + preloadBuffer) {
                                    preloadTiles.push(tileInfo);
                                }
                            }
                        }
                    });
                }
                
                // 按z-index排序
                visibleTiles.sort((a, b) => a.zIndex - b.zIndex);
                preloadTiles.sort((a, b) => a.zIndex - b.zIndex);
                
                // 渲染可视瓦片
                visibleTiles.forEach(tileInfo => {
                    this.createTileFromInfo(tileInfo, false);
                });
                
                // 预载瓦片
                this.preloadTiles(preloadTiles);

                this.updateTransform();
                this.updateCoordinates();
            }

            preloadTiles(tiles) {
                // 清空预载队列
                this.preloadQueue = [];
                
                // 添加到预载队列
                tiles.forEach(tileInfo => {
                    const tileKey = `${tileInfo.file}_${this.currentZoom}`;
                    if (!this.loadedTiles.has(tileKey)) {
                        this.preloadQueue.push(tileInfo);
                    }
                });
                
                // 开始预载
                this.processPreloadQueue();
            }

            processPreloadQueue() {
                if (this.preloadQueue.length === 0) return;
                
                // 每次处理几个瓦片，避免阻塞
                const batchSize = 3;
                const batch = this.preloadQueue.splice(0, batchSize);
                
                batch.forEach(tileInfo => {
                    this.preloadTile(tileInfo);
                });
                
                // 继续处理剩余的瓦片
                if (this.preloadQueue.length > 0) {
                    setTimeout(() => this.processPreloadQueue(), 50);
                }
            }

            preloadTile(tileInfo) {
                const tileKey = `${tileInfo.file}_${this.currentZoom}`;
                if (this.loadedTiles.has(tileKey)) return;
                
                const img = new Image();
                img.onload = () => {
                    this.loadedTiles.add(tileKey);
                };
                img.onerror = () => {
                    // 预载失败，不做特殊处理
                };
                img.src = `./map/${tileInfo.file}`;
            }

            calculateZIndex(chunk) {
                if (!this.mapData["z-index"][chunk] && this.mapData["z-index"][chunk] !== 0) console.log("没有找到层级数据", chunk);
                return this.mapData["z-index"][chunk]
            }
            

            render() {
                if (!this.mapData || !this.mapData[this.currentZoom]) return;

                // 清空当前地图
                this.mapCanvas.innerHTML = '';

                const zoomData = this.mapData[this.currentZoom];
                
                // 收集所有瓦片信息并按层级排序
                const allTiles = [];
                for (const [chunkKey, tiles] of Object.entries(zoomData)) {
                    tiles.forEach(tileFile => {
                        const match = tileFile.match(/r_(\d+)_([^_]+)_(\d+)_(\d+)\.png/);
                        if (match) {
                            const [, zoomLevel, chunk, x, y] = match;
                            const tileX = parseInt(x);
                            const tileY = parseInt(y);
                            
                            // 计算瓦片在屏幕上的位置
                            const screenX = (tileX - this.centerX) * this.tileSize;
                            const screenY = (tileY - this.centerY) * this.tileSize;
                            
                            // 检查是否在可视范围内
                            const buffer = this.tileSize * 2;
                            if (screenX >= -this.offsetX - buffer && 
                                screenX <= -this.offsetX + this.viewportWidth + buffer &&
                                screenY >= -this.offsetY - buffer && 
                                screenY <= -this.offsetY + this.viewportHeight + buffer) {
                                
                                allTiles.push({
                                    file: tileFile,
                                    chunk: chunk,
                                    x: tileX,
                                    y: tileY,
                                    screenX: screenX,
                                    screenY: screenY,
                                    zIndex: this.calculateZIndex(chunk)
                                });
                            }
                        }
                    });
                }
                
                // 按z-index排序（小的先渲染，大的后渲染，这样大的会在上面）
                allTiles.sort((a, b) => a.zIndex - b.zIndex);
                
                // 渲染瓦片
                allTiles.forEach(tileInfo => {
                    this.createTileFromInfo(tileInfo);
                });

                this.updateTransform();
                this.updateCoordinates();
            }

            createTile(tileFile, chunkKey) {
                // 解析文件名获取坐标 r_0_10_495_503.png
                const match = tileFile.match(/r_(\d+)_([^_]+)_(\d+)_(\d+)\.png/);
                if (!match) return;

                const [, zoomLevel, chunk, x, y] = match;
                const tileX = parseInt(x);
                const tileY = parseInt(y);

                // 计算瓦片在屏幕上的位置（以500,500为中心）
                const screenX = (tileX - this.centerX) * this.tileSize;
                const screenY = (tileY - this.centerY) * this.tileSize; // Y轴翻转

                // 检查是否在可视范围内（包含缓冲区）
                const buffer = this.tileSize * 2;
                if (screenX < -this.offsetX - buffer || 
                    screenX > -this.offsetX + this.viewportWidth + buffer ||
                    screenY < -this.offsetY - buffer || 
                    screenY > -this.offsetY + this.viewportHeight + buffer) {
                    return; // 不在可视范围内，跳过
                }

                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.left = `${screenX}px`;
                tile.style.top = `${screenY}px`;
                
                // 计算z-index：数字和字母越小，层级越高
                const zIndex = this.calculateZIndex(chunk);
                tile.style.zIndex = zIndex;
                
                // 尝试加载图片
                const img = new Image();
                img.onload = () => {
                    tile.style.backgroundImage = `url(./map/${tileFile})`;
                };
                img.onerror = () => {
                    // 如果图片加载失败，显示占位符
                    tile.style.backgroundColor = '#333';
                    tile.style.border = '1px solid #666';
                    tile.innerHTML = `<div style="padding: 10px; font-size: 10px; color: #999;">${tileX},${tileY}<br>Layer: ${chunk}<br>Z: ${zIndex}</div>`;
                };
                img.src = `./map/${tileFile}`;

                this.mapCanvas.appendChild(tile);
            }

            createTileFromInfo(tileInfo, isPreload = false) {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.style.left = `${tileInfo.screenX}px`;
                tile.style.top = `${tileInfo.screenY}px`;
                tile.style.zIndex = tileInfo.zIndex;
                
                const tileKey = `${tileInfo.file}_${this.currentZoom}`;
                
                // 尝试加载图片
                const img = new Image();
                img.onload = () => {
                    tile.style.backgroundImage = `url(./map/${tileInfo.file})`;
                    // 添加加载完成的动画类
                    requestAnimationFrame(() => {
                        tile.classList.add('loaded');
                    });
                    this.loadedTiles.add(tileKey);
                };
                img.onerror = () => {
                    // 如果图片加载失败，显示占位符
                    tile.style.backgroundColor = '#333';
                    /* tile.style.border = '1px solid #666'; */
                    tile.innerHTML = `<div style="padding: 10px; font-size: 10px; color: #999;">${tileInfo.x},${tileInfo.y}<br>Layer: ${tileInfo.chunk}<br>Z: ${tileInfo.zIndex}</div>`;
                    // 即使失败也添加loaded类以显示占位符
                    requestAnimationFrame(() => {
                        tile.classList.add('loaded');
                    });
                };
                
                // 如果瓦片已经预载过，立即显示
                if (this.loadedTiles.has(tileKey)) {
                    img.src = `./map/${tileInfo.file}`;
                } else {
                    // 延迟一帧再开始加载，确保DOM更新
                    requestAnimationFrame(() => {
                        img.src = `./map/${tileInfo.file}`;
                    });
                }

                this.mapCanvas.appendChild(tile);
            }
        }

        // 初始化地图查看器
        document.addEventListener('DOMContentLoaded', () => {
            new MapViewer();
        });
    </script>
    <script defer src="https://analytics.ravelloh.top/script.js" data-website-id="3844fb6d-2dee-4d65-b84a-25b31b053d0e"></script>
</body>
</html>
